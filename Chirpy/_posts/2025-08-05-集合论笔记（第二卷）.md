---
title: 集合论笔记（第二卷）
author: me
date: 2025-08-05 14:53:32 +0800
description: 记录一些我思考了很久或者很重要的笔记
categories: [数学,集合论]
math: true
tags: [数学,集合论,疑问,笔记]
---
[第一卷](../集合论笔记/)
## 植入逻辑学概念（1.1）
数学思维中，人们总是有一定的外在思维环境 (不妨称之为元数学环境) 和一定的关注对象与问题 (不妨称之为目标数学论域)。有一些定义是在元数学环境中定义的，并不是内在化论域中的，比如书中举的关于$$\forall,\exists$$就需要对集合论论域中的全部集合进行某种讨论，所以是外在于集合论的论域的，是元数学环境中的一种定义。
>就符号资源而言,集合论元数学形式语言的符号包括如下逻辑符号:
>
>(1)等号  $$\hat{=}$$ ,否定词符号  $$\neg$$ ,蕴涵符号  $$\rightarrow$$ ,析取符号  $$\vee$$ ,合取符号  $$\wedge$$ ,对等符号  $$\leftrightarrow$$ ;
>
>(2)全称量词符号  $$\forall$$ ,存在量词符号  $$\exists$$ ;
>
>(3)左右圆括弧  $$(,)$$
>
>(4)对于每一个元数学的自然数  $$n$$ ,有一个形式变元符号  $$v_{n}$$ 和以此为基础的简单的递归定义原理与数学归纳法原理
>
>以及唯一一个非逻辑符号:用以表示当前论域中集合之间的属于关系的二元谓词符号  $$\in$$ ;所有这些符号都彼此互不相同.
>
>更一般地,在元数学环境下数理逻辑形式语言的符号表由如下对象组成:
>
>(1)上面罗列出来的逻辑符号;
>
>(2)无穷可数多个常元符号,  $$c_{n}$$ ,其中  $$n$$  是一个自然数;
>
>(3)无穷可数多个函数符号,  $$F_{n}$$ ,其中  $$n$$  是一个自然数,并且每一个函数符号都有唯一确定的正整数作为它的变元个数,以及对于每一个正整数  $$k$$ ,函数符号  $$F_{j}$$  为  $$k$$ -元函数符号的下标  $$j$$  有无穷多个;
>
>(4)无穷可数多个谓词符号,  $$P_{n}$$ ,其中  $$n$$  是一个自然数,并且每一个谓词符号都有唯一确定的正整数作为它的变元个数,以及对于每一个正整数  $$k$$ ,谓词符号  $$P_{j}$$  为  $$k$$ -元谓词符号的下标  $$j$$  有无穷多个;
>
>(5)上述逻辑符号、常元符号、函数符号以及谓词符号都彼此互不相同.
>
>需要明确指出的是,上面涉及的自然数以及各种符号都是元数学环境中的资源.在元数学中,任何一个可数语言都由上述符号中的全体变元符号和一部分常元符号、函数符号以及谓词符号按照统一的规范的形成过程给出,也就是说,一种语言与另一种语言的差别就在于它们所具有的函数符号、谓词符号以及常元符号的某些不同;我们不妨设定  $$P_{0}$$  是二元谓词符号  $$\in$$ .

而且不同的表达式长度是确定的，我们可以对这些表达式根据长度递归（在元数学环境中递归）。而某种语言$$\mathcal L_{\mathcal A}$$也是先确定符号表$$\mathcal A$$中我们可以使用哪些常元符号、函数符号和谓词符号（比如$$\in,=$$就是谓词符号），然后使用除了谓词符号以外的项组合得到项，再用谓词符号组合项，得到初始表达式，最后使用几个逻辑关系符号组合形式表达式。我们的目的就是把元数学环境中的集合论形式语言（外在形式语言）内化到集合论环境中去。<br><br>
在语言$$\mathcal L_{\mathcal A}$$中，除开逻辑公理，还有一些语句列表（叫非逻辑公理表），我们的推理也基于这些语句进行推理。显然，非逻辑公里表就是语言$$\mathcal L_{\mathcal A}$$的公理。<br><br>
还有$$\Delta_0(\mathcal A)-$$表达式
>(1)如果  $$P\in \mathcal{A}$$  是一个  $$k$$  - 元谓词,  $$t_{i_{1}},\dots ,t_{i_{k}}$$  是  $$k$$  个项,那么
>
>$$
P(t_{i_{1}},\dots ,t_{i_{k}})
$$
>
>是一个  $$\Delta_{0}(\mathcal{A})$$  - 表达式;
>
>(2)如果  $$t_{1}$$  和  $$t_{2}$$  是两个项,那么等式  $$(t_{1}\hat{=} t_{2})$$  是一个  $$\Delta_{0}(\mathcal{A})$$  -表达式;
>
>(3)如果  $$\phi$$  是一个  $$\Delta_{0}(\mathcal{A})$$  -表达式,那么  $$(\neg \phi)$$  是一个  $$\Delta_{0}(\mathcal{A})$$  -表达式;
>
>(4)如果  $$\phi$$  和  $$\psi$$  是两个  $$\Delta_{0}(\mathcal A)$$ -表达式,那么
>
>$$
(\phi \rightarrow \psi), (\phi \leftrightarrow \psi), (\phi \land \psi), (\phi \lor \psi)
$$
>
>都是  $$\Delta_{0}(\mathcal A)$$ - 表达式;
>
>(5)如果  $$\phi$$  是一个  $$\Delta_{0}(\mathcal A)$$ -表达式,  $$\tau$$  是一个项,  $$v_{i}$$  是一个不在项  $$\tau$$  中出现的变元符号,那么
>
>$$
(\forall v_{i}(v_{i} \in \tau \rightarrow \phi)), (\exists v_{i}(v_{i} \in \tau \land \phi))
$$
>
>都是  $$\Delta_{0}(\mathcal A)$$ - 表达式;此时,约定将表达式  $$(\forall v_{i}(v_{i} \in \tau \rightarrow \phi))$$  简写成
>
>$$
(\forall v_{i} \in \tau \phi),
$$
>
>将表达式  $$(\exists v_{i}(v_{i} \in \tau \land \phi))$$  简写成
>
>$$
(\exists v_{i} \in \tau \phi).
$$
>
>(6)任何一个  $$\Delta_{0}(A)$$ -表达式都必然地为上述五种情形之一,别无其他

实际上也就是对任意的表达式加以了限制——对于限制变元，我们需要限制其变化范围（第五条说明的）。对于没有限制变化范围的限制变元，我们就可以定义$$\sum_n,\prod_n$$阶的表达式（和这种限制变元种类变化次数有关，详见41页，即书22页）。可是我们为什么要限制取值范围呢？我们前面讨论过，如果不限制取值范围，我们的定义，或者是证明，将变成某种基于元数学环境的、外在的东西。为了保证可以内化，我们必须杜绝这种情况的发生，所以必须加以限制。但是有的表达式就是不能限制啊，这怎么办呢？（我现在还不知道）
## $$\mathrm {KP}^-$$公理体系
$$\mathrm{KP}_{\mathcal A}^-$$语言下的集合理论$$\mathrm{KP}_{\mathcal A}^-$$是下述语句的集合:<br><br>
同一律:  $$\forall v_{1}\forall v_{2}((\forall v_{3}(v_{3}\in v_{1}\leftrightarrow v_{3}\in v_{2}))\rightarrow (v_{1} = v_{2}));$$<br><br>
$$\in$$ - 极小原理:  $$\forall v_{1}\dots \forall v_{n}\theta (\vec{v})$$ ,其中,  $$\theta (\vec{v})$$  是下述命题:

$$
\left(\begin{array}{l}{(\exists v_{n+1}\phi(v_{1},\cdots,v_{n},v_{n+1}))\rightarrow}\\ {(\exists v_{n+1}(\phi(v_{1},\cdots,v_{n},v_{n+1})\land\forall v_{n+2}\in v_{n+1}(\neg\phi(v_{1},\cdots,v_{n},v_{n+2})))}\end{array}\right),
$$

其中  $$\phi (v_{1},\dots ,v_{n},v_{n + 1})$$  是一个彰显自由变元表达式,  $$\forall n + 2$$  并未在  $$\phi$$  中出现, $$\phi (v_{1},\dots ,v_{n},v_{n + 2})$$  是在  $$\phi$$  中用  $$v_{n + 2}$$  替换  $$v_{n + 1}$$  所得到的结果<br><br>
二元集合公理:  $$\forall v_{1}\forall v_{2}\exists v_{3}(v_{1}\in v_{3}\land v_{2}\in v_{3})$$<br><br>
并集合公理:  $$\forall v_{1}\exists v_{2}\forall v_{3}\in v_{1}\forall v_{4}\in v_{3}(v_{4}\in v_{2})$$<br><br>
$$\Delta_{0}(\mathcal{A})$$ - 分解原理:

$$
\forall v_{1}\dots \forall v_{n}\forall v_{n + 1}\exists v_{n + 3}\forall v_{n + 4}\left( \begin{array}{l}{v_{n + 4}\in v_{n + 3}\leftrightarrow}\\ {(v_{n + 4}\in v_{n + 1}\land \phi (v_{1},\dots ,v_{n},v_{n + 4}))} \end{array} \right),
$$

其中  $$\phi (v_{1},\dots ,v_{n},v_{n + 1})$$  是一个彰显自由变元的  $$\Delta_{0}(\mathcal{A})$$ - 表达式,变元符号  $$v_{n + 3}$$  和  $$v_{n + 4}$$  并未在  $$\phi$$  中出现, $$\phi (v_{1},\dots ,v_{n},v_{n + 4})$$  是在  $$\phi$$  中用  $$v_{n + 4}$$  替换  $$v_{n + 1}$$  所得到的结果<br><br>
$$\Delta_{0}(\mathcal{A})$$ - 收集原理:  $$\forall v_{1}\dots \forall v_{n}\forall v_{n + 1}\Psi (\vec{v})$$ ,其中  $$\Psi (\vec{v})$$  是下述命题:

$$
\left( \begin{array}{l}{(\forall v_{n + 2}\in v_{n + 1}\exists v_{n + 3}\phi (v_{1},\dots ,v_{n},v_{n + 1},v_{n + 2},v_{n + 3}))\rightarrow}\\ {(\exists v_{n + 4}(\forall v_{n + 2}\in v_{n + 1}\exists v_{n + 3}\in v_{n + 4}\phi (v_{1},\dots ,v_{n},v_{n + 1},v_{n + 2},v_{n + 3})))} \end{array} \right),
$$

其中  $$\phi (v_{1},\dots ,v_{n},v_{n + 1},v_{n + 2},v_{n + 3})$$  是一个彰显自由变元的  $$\Delta_{0}(\mathcal{A})$$ - 表达式,变元符号  $$v_{n + 4}$$  并未在  $$\phi$$  中出现<br><br>
定义1.7(1)当  $$\mathcal{A} = \{\in \}$$  时,用  $$\mathrm{KP}^{- }$$  来记  $$\mathrm{KP}_{\mathcal{A}}^{- }$$ ;

(2) 用$$\mathrm{KP}_A$$ 来记理论 $$\mathrm{KP}_A^-$$加上如下形式的无穷公理所得到的理论:

$$
\exists v_{1}\left( \begin{array}{l}{(\exists v_{2}\in v_{1}(\neg (\exists v_{3}(v_{3}\in v_{2})))\wedge}\\ {(\forall v_{2}\in v_{1}\exists v_{3}\in v_{1}(v_{3} = v_{2}\cup \{v_{2}\}))\wedge}\\ {(\forall v_{2}\in v_{1}(\{\exists v_{3}(v_{3}\in v_{2})\} \rightarrow (\exists v_{3}\in v_{2}(v_{2} = v_{3}\cup \{v_{3}\})))\wedge}\\ {(\forall v_{2}\in v_{1}\forall v_{3}\in v_{1}(v_{2} = v_{3}\vee v_{2}\in v_{3}\vee v_{3}\in v_{2}))\wedge}\\ {(\forall v_{2}\in v_{1}\forall v_{3}\in v_{2}\forall v_{4}\in v_{3}(v_{4}\in v_{2}))\wedge}\\ {(\forall v_{2}\in v_{1}\forall v_{3}\in v_{2}(v_{3}\in v_{1}))} \end{array} \right),
$$

## 归纳原理
第一$$\in-$$归纳原理：59页（书40页）：<br>
设 $$\phi(x)$$是一个表达式 (可能含有未显示的自由变元)。 那么

$$
\mathrm{KP}^{-}\vdash ((\forall x((\forall y\in x\phi (y))\rightarrow \phi (x)))\rightarrow (\forall x\phi (x)))
$$

值得注意的是，这个定理并没有限制$$\phi(x)$$是一个怎么样的表达式，也就是说，$$\phi(x)$$可以是任意的表达式，甚至不是$$\Sigma-$$或者$$\Pi-$$表达式。<br><br>
第二$$\in-$$归纳原理：62页（书43页）：<br>
设$$\phi(x)$$为一个解析表达式。那么

$$
\mathrm{KP}^{-} \vdash ((\forall x ((\forall y \in \mathcal{T C}(x) \phi (y)) \rightarrow \phi (x))) \rightarrow (\forall x \phi (x)))
$$

仔细看会发现这个定理必前面的强，因为条件更多了（对于传递集合则相同）
## $$\Delta_0$$表达式的绝对性
页数：86页(书67页)
### 原文
定理1.19($$\Delta_{0}$$绝对性)设  $$\phi (v_{1},\dots ,v_{n})$$  是一个  $$\Delta_{0}$$  表达式，那么<br><br>
(1)

$$
\begin{array}{r@{\,}l}
\,\mathrm{ZF}\vdash & \left(\forall M\forall N\left(\left(M\neq\varnothing\land\left(\forall x\in M(x\subset M)\right)\land M\subseteq N\right)\to{}\right.\right.\\
& \phantom{\mathrm{ZF}\vdash (}\left.\left.\forall x_{1}\in M\cdots\forall x_{n}\in M\left(\begin{gathered}
{\left(M\models\varphi[x_{1},\cdots,x_{n}]\right)}\\
\leftrightarrow\\
{\left(N\models\varphi[x_{1},\cdots,x_{n}]\right)}
\end{gathered}\right)\right)\right)
\end{array}
$$

<br>(2)

$$
\begin{array}{r@{\,}l}\mathrm{ZF}\vdash & \left(\forall M\left(\left(M\neq\varnothing\land\left(\forall x\in M(x\subset M)\right)\right)\to{}\right.\right.\\
& \phantom{\mathrm{ZF}\vdash (}\left.\left.\forall x_{1}\in M\cdots\forall x_{n}\in M\left(\begin{gathered}
\varphi(x_{1},\cdots,x_{n})\\
\leftrightarrow\\
M\models\varphi[x_{1},\cdots,x_{n}]
\end{gathered}\right)\right)\right)
\end{array}
$$
### 意义
这意味着$$\Delta_0$$表达式在任何传递类上进行限制都不会对其含义有任何的影响，在任何传递类上的限制，其都保持相同。这也就保证了，在大多数集合论的模型中（因为这些模型大多传递），任何一个理论的$$\Delta_0$$表达式在其对应的多数理论中都是相同的
## 广义镜像原理
页数：112页(书93页)<br><br>
定理1.29(广义镜像原理)设  $$\langle \varphi_{0},\varphi_{1},\dots ,\varphi_{k - 1}\rangle$$  为  $$\in$$  形式表达式的一个列表.假设  $$W$$  是一个非空的类,以及对于每一个序数  $$\alpha ,U_{\alpha}$$  是一个集合.进一步地假设

(1)对于任意两个序数  $$\alpha < \beta$$  都有  $$U_{\alpha}\subseteq U_{\beta}$$

(2)对于每一个极限序数  $$\delta$$  都有  $$U_{\delta} = \bigcup\limits_{\alpha < \delta}U_{\alpha}$$

(3)  $$W = \bigcup\limits_{\alpha \in \mathrm{Ord}}U_{\alpha}$$

那么下述成立:

$$
\forall\alpha\exists\beta\left(\alpha\in\beta\land\beta\in\mathrm{LimOrd}\land U_\beta\neq\varnothing\land\bigwedge_{i<k}\left(U_\beta\prec_{\varphi_{i}}W\right)\right).
$$

## 共尾子集
起因见[问题](../我的集合论问题-第二卷/#推论18证明)<br><br>
**这部分主要探讨一个问题：为什么能够存在共尾子集，尤其是书中几个定理是如何避免存在函数与共尾子集中所有函数都没有序关系的**<br><br>
通过返回去重新看书，我发现有两处关键的地方（两处相互之间没有依赖，是不同的证明）：定理1.31（断言三）、引理1.22（末尾），页数分别为118页(书99页)、120页(101页)。<br><br>
### 定理1.31
定理1.31通过证明语句

$$
(\neg (\exists f\in \Pi (\omega ,K)(f< _{I}g\wedge \forall \xi < \kappa^{+}(f\not\leq_{I}f_{\xi}))))
$$

排除了全部可能与$$f_\xi$$无序关系的$$f$$们，方法则是通过证明$$<_I$$上界$$g$$与$$f_\xi$$十分接近，以至于任何无序关系的$$f$$都不可能夹在中间。因为任何与$$f_\xi$$没有序关系的函数都必须有很多个函数值大于$$f_\xi$$而且同时很多个函数值小于$$f_\xi$$（这样才能保证两个对应的集合不在$$I$$中），可是$$g,f_\xi$$十分接近阻止了$$f_\xi$$这么做。最后，通过一个映射将$$f_\xi$$们映射到$$\kappa$$上去（$$g$$同时被映射到$$\kappa$$上）。
### 引理1.22
再来看引理1.22，类似的方法，不过是直接正面证明的，步骤则是先找到上界$$f$$满足的一个重要条件：上界几乎与序列中的各个函数相等（同样是两者十分地接近），然后证明任何函数$$h$$都一定会几乎小于某个$$f_\alpha$$。而做到证明两者十分接近的重要一步就是前面找到的同质子模型$$M$$，因为只有这样我们才能居高临下地审视$$f$$与$$f_\alpha$$们究竟有多么接近。

---
总结来说，避免出现不可比的情况的重要一步便是证明我们的序列增长地极其快，与上界直接几乎没什么空间能够允许别的函数。而要证明这一步，我们必须缩小我们讨论的范围，将其局限在某一个区域内（比如1.31的$$g$$，又或是1.22的$$M$$）。否则又要有上界，还要充分大，与上界间不留下任何空间，“从下往上”是几乎不可能证明的，因而做这样的限制就是必须的了。

## 凝聚化引理
页数：196页(书177页)
### 内容
定理2.10(凝聚化引理)设  $\alpha >0$  是一个极限序数,  $X\subseteq L_{\alpha}$  如果

$$
(X,\in)\prec_{1}(L_{\alpha},\in),
$$

那么存在唯一的函数  $\pi$  以及序数  $\beta \leq \alpha$  来见证下述事实:<br>
(a)  $\pi :(X,\in)\cong (L_{\beta},\in)$<br>
(b)如果  $Y\subseteq X$  是一个传递集合,那么  $(\forall x\in Y(\pi (x) = x))$<br>
(c)  $(\forall x\in X(\pi (x)\leq x))$
### 理解
首先，我们注意到一个基本事实：$\beta$一定是一个极限序数，这是基于$X$中的一个事实：若有序数$\alpha\in X$，则$\forall n<\omega(\alpha+n\in X)$，这是任何子模型$X$都应该满足的。那么，如果$\beta$是一个后继序数，那么$X$中的序数数目肯定也只是后继序数个了，但是这显然是不可能的。<br><br>
接下来就是关于这个定理本质的理解了，看书之后我们会看到这个定理最主要的两个应用——在证明$\mathrm{ZF} + (V=L)\vdash\mathrm{GCH}$和$\mathrm{ZF} + (V = L) \vdash "存在一个钻石序列"$中最后时刻的决定性压缩——将$\omega_1$压缩到一个可数序数$\alpha$。分析这两个证明过程，这里面最关键的两步分别是**构造可数同质子模型$M$** 以及 **将$M$映射（压缩）到可数层$L_\beta$**，接下来我们分别来分析一下这两个关键步骤。<br><br>
#### 构造可数子模型$M$
首先，为什么可以这样构造，这个很简单，使用斯科伦函数构造斯科伦闭包（一定存在，这个意思是用给定的可数个集合一步步套[可定义集合](../集合论第二卷概念辨析/#mathfrak-d)，最终套出来的模型）。其次，这个模型不仅仅构造出来就可以，它还满足一些基本的性质，而这些性质对我们后面的映射至关重要。最主要的，这样构造出来的模型一定是可数的大小，从而必定不含有不可数个的序数，从而$M\cap\omega_1=\alpha<\omega_1$（自然，这个$\alpha$是一个极限序数，原因上面说过了），也就是说如果进行映射（压缩），$\omega_1$下面缺少了很多的序数，其必定塌缩下来到可数的地位。而且由于可数，最终凝聚化映射所映射到的也一定是一个可数层的$L_\beta$。
#### $M$压缩到可数层
这一步可以说是最最关键的一步了，这里我们先考虑映射后的情况，由于$M$的性质，映射到的一定是一个可数极限序数$\beta$对应的层$L_\beta$，又由于两者是$\in$关系上同构的，我们来考虑为什么$\omega_1$只能映射到$\alpha$，其他的集合映射也是相同的道理，只不过$\omega_1$相对更好理解一些。如果$\omega_1$映射到大于$\alpha$的序数，可是$\alpha$是属于$L_\beta$的，也就是说在属于关系上，$M$也应该再找一个序数出来顶替$\alpha$的位置（也就是映射上去），可是我们已经说过了，由$\alpha$的定义，不可能还有哪个$M$中的序数能出来顶替这个位置，所以$\omega_1$只能映射到$\alpha$。同样地去考虑其他的集合，各种其他的集合也自然而然地只能映射到那种截断上了。不过还有另一种理解方法，注意到我们构造$M$使用的是可数步的斯科伦函数闭包构造，能构造出来的东西肯定也不会有超过$\omega_1$的复杂度，对于我们在证明中构造出来的一大堆$\omega_1$层的结构，我们也不可能真的能在$M$中找到那样复杂的东西，只能找到在某一步可数层就截断了的残余，所以其他各种集合也只能是可数步就消失不再递归了。<br><br>
接下来我认为需要说明的是为什么这种压缩是可行的，很明显，这两个证明都十分地依赖于将$\omega_1$压缩到可数序数$\alpha$，而这正依赖于模型$M$仅仅是可数大小，这意味着它没有超高的复杂度（只需要可数的构造步数就能构造出来，所以自然在模型$L_{\omega_1}$中能找到一个可数层数装下它的全部），我们一定可以将它压缩到一个可数序数，同时其内部的全部结构也压缩到可数级别，这一切都是因为凝聚化引理中的$X$（也是这里的$M$）内部只有可数的复杂度，其一定是可以向下压缩，减去其中的各种空隙（比如$\alpha$和$\omega_1$中的空隙），当作传递模型考虑的。