---
title: 大开脑洞的数学问题
author: me
date: 2025-04-22 21:37:22 +0800
description: 关于我或者XZN都整出了哪些奇葩问题
categories: [数学,奇思妙想]
math: true
tags: [数学,问题,思考]
---
## 通过任一点的可导函数

这个问题是XZN提出的，提出原因不明(可能闲得慌😜)

### 问题

如果任意给定一组可列点列$A:i\in\mathbb N,(x_i,y_i)$，且$\forall i,j\in\mathbb N(i\neq j\Longleftrightarrow x_i\neq x_j)$，能否定义一个函数$f$，使得$f(x_i)=y_i$，且$f$在$\mathbb R$上无穷阶可导

### 回答

首先，这个原命题的回答是不一定，当给定点列$A$有多个聚点时不一定能定义，毕竟这时通过所有点的函数都不一定在$\mathbb R$上连续，比如如下点列

$$
(x_i,\sin{\frac{1}{x_i}}),x_i\in\mathbb Q\ \wedge\langle x_i\rangle点列以0为唯一聚点
$$

而针对仅有唯一聚点的情况，我们断言，**一定存在对应的函数**，不仅如此，甚至我们可以构造出可列个线性无关的这样的$f$，证明如下<br><br>
首先假设$\forall i,j\in\mathbb N(i<j\Longleftrightarrow |x_i|>|x_j|)$记$\epsilon_i=\frac{|x_i|+|x_{i+1}|}{2}$，这样我们就将取到的点列$A$通过$\epsilon_i$进行了划分，接下来对于任意给定的$i\in\mathbb N$，我们对于$a<i$都只有有限个$x_a$，如果我们对于任意的$i$，都可以定义出这个区间上的任意阶可导的函数$f_i$，并且保证所有的$f_i$构成和谐函数系统(或者叫不冲突，即只要函数有定义就有$\forall x,f_i(x)=f_j(x)$)，集合论就保证存在$f=\bigcup{f_i}$，显然这个$f$就是我们要找的那个函数。<br><br>
对于这样的点列，我们还可以做一种简化，将唯一的聚点移动到原点，这并不影响函数的存在性（如果聚点是无穷远点情况类似，读者可自己尝试证明）。然后很巧的是，我们又注意到若定义$f_i$为如下的函数，即可满足我们的条件：

$$
f_i(x)=\sum\limits_{a=0}^i \alpha_ie^{\frac{1}{-(\epsilon_i-x)^2}}
$$

若在函数中取合适的$\alpha_i$，使得函数通过$(x_i,y_i)$即可，并且可以验证这样的$f_i$在所有的$\epsilon_i$上也是无穷阶可导的，因而我们的命题得证。😏<br><br>
好吧开个玩笑，这个函数当然不是随意构造出来的，下面我简述一下构造其的思路。回到聚点邻域外的有限个点，我们很容易就会尝试考虑多项式函数，毕竟这里只有有限个嘛(如果假设是$m$个)，一个$m-1$阶的多项式$P_m$就可以解决问题，然后如果再加上里面的下一个点，现在我们自然地想到在$(\epsilon_{m+1},\epsilon_m)$间在定义一个$m+1$次多项式$P_{m+1}$，接下来我们只需要保证这两个多项式函数在衔接点$\epsilon_m$出无穷阶可导即可<br><br>
可是问题也正好在此，我们考虑这个多项式$P_{m+1}$，我们可以通过衔接点$\epsilon_m$处$P_m$的$m$阶导数提供的$m$个方程和点$(x_{m+1},y_{m+1})$提供的$1$个方程求出其各项系数，但是这会导致一个问题，如何保证$P_{m+1}$在$\epsilon_m$处的$m+1$阶导数为零呢，除了添加新的参数，我们没有办法保证这一点，但是如果添加一个参数，我们又怎么保证更高阶的导数呢，毕竟$\epsilon_m$处有无穷阶导数，它们都应该等于零嘛。显然我们不能仅仅通过多项式衔接两个区域，这迫使我们思考其他的函数。<br><br>
其实我们遇到的问题仅仅是希望添加一个参数，使得我们的函数通过下一个点，但同时不要影响原来的导数值，那么如果存在一个函数$g$，满足$g^{(n)}(0)=0$，然后我们令$f_{m+1}(x)=f_m(x)+\alpha_{m+1} g(x-\epsilon_m)$，这样衔接点的各阶导数值都不改变，衔接很自然，然后我们再调整$\alpha_{m+1}$使得$f_{m+1}$通过点$(x_{m+1},y_{m+1})$即可。可能有的读者已经想到了，没错就是这个函数，它就是前面出现的：

$$
e^{\frac{1}{-(\epsilon_m-x)^2}}
$$

读者可以自行验证这个函数在$\epsilon_m$点处确实各阶导数为0，于是我们最后就可以定义函数$f_i$，从而定义出$f$。更进一步，既然我们定义的$f_i$都没有提高多项式阶数，那我们定义起点（先取有限个点定义它们上的可导函数）可以是任意阶的（甚至不是多项式）函数，而且不论怎样的定义起点，我们都可以归纳定义出一个全新的$f$来，而且这些$f$之间都是线性无关的<br><br>
总结：若点列$A$仅有一个聚点，一定是可以定义出一个函数$f$，使得$f(x_i)=y_i$，且$f$在$\mathbb R$上无穷阶可导。
## 一笔画
最近在玩一笔画的小游戏，因而有兴致思考什么样的图形可以一笔画出（当然我知道这个问题肯定不少人都已经研究过了，不过我的确没有去看他们的研究成果，下面的部分都是我自己的研究成果。<br><br>
### 什么是一笔画出
首先，定义什么叫做将图形一笔画出相当的重要，对此，我采用的定义如下：<br>
若对于一个连通图，存在一个对应的有向图，对于此有向图中的每个点，考虑指向和远离此点的箭头的数量之差，若对图中所有点，此值均为0，或者有一个点为1，一个点为-1，而其余点均为0，我们称这个图可以一笔画出。<br><br>
这个定义是很显然的，要么一笔画的出发点和终止点相同（所有点都为0），要么不同（第二种情况），这种情况一定能保证我们可以沿着这个有向图一笔将其画出。
### 一笔画的充要条件
然后，我们便需要考虑什么样的图是可以一笔画出的了。显然，根据定义我们不难知道，一个图中对于所有点连接的线段数目，要么全都是偶数个，要么仅有两个点是奇数条，而其他所有点都是偶数条才是有可能一笔画出的。然后经过我自己尝试，我怀疑这不仅是必要条件，更是充分条件，因为每一个这样的图都可以一笔画出，所以我猜测一个连通图可以一笔画出的充要条件是

$$
所有点连接的线段数目，要么全都是偶数个，要么仅有两个点是奇数条，而其他所有点都是偶数条
$$

而证明也很简单，只需要稍微使用归纳法即可，不过在那之前，我们需首先处理一下第二种情况，很明显，如果我们将两个奇数条线段的点连起来，这个图仍然可以一笔画出，反之，如果这个加了线段之后的图可以一笔画出，那原来没加的也可以一笔画出。这也就是说两者是等价的，只有第一种情况一定能画出，那对于所有第二种情况的图也一定能画出。所以下面我们只需要重点考虑第二种情况就好了。<br><br>
递归地，如果对所有有$n$个点的连通图结论都成立，我们来证明对有$n+1$个点的图结论也都成立。这时我们还要对第$n+1$个点上所有的线数做递归，假设对$n+1$个点上有$2m$条线<br><br>
首先递归假设，对$m=1$时，若去除这两条线，剩下的$n$个点可一笔画出，而这时$n$个点形成的图形就是第二种情况对应的图形，而且这个图形一笔画的起止点是确定的，就是和$n+1$最初相连的点（用我们前面的定义是很严谨的），我们只需要补上我们最开始去掉的两根线，很明显地存在有向图满足定义，也就是可以一笔画出。<br><br>
对于$m>1$的情况是很类似的，只不过去掉两根线后，先让$n+1$个点生成有向图，然后再补上去掉的两根线即可。<br><br>
从而，通过递归，我们便证明了我们上述的条件就是充要条件，只需要观察所有点连了几条线，就可以判断这个图能不能一笔画出。
### 生成一笔画的方法
不过到这里我还需要研究一个问题——如果一个图形可以一笔画，有没有一个方法能够保证任意可以一笔画的图形我都能直接生成出一笔画的方法，从而做到任意图我都能直接秒杀？<br><br>
首先，在多次实践中，我发现好像对于能够一笔画出的图来说，那些失败的画法都是只画出了它的其中一个子图，然后就卡在死胡同里了，也就是说只要能尽可能去走遍全部路线就可以了，只要能保证下一步还有得走就都有机会，所以我猜测只需要保证每一步后面都是连通图就好了，实际上可以证明，这样做的确一定能画出全部图像，只需要递归就可以证明，去掉最后一笔，这个策略能画出前面全部的，那最后一笔补上就好了嘛（要考虑两种图像的情况，分开论证一下，但是都不难，这里就不再赘述）<br><br>
可是如上的算法的确可以用，不过对于计算机来说还是太难了，判断连通图是一个十分复杂且困难的事情，所以我们仍然希望能找到一个不依赖递归的算法，一步就直接生成全部图形。不过我们前面所有的过程都依赖于递归，要画法生成器不递归的确很困难，不过所幸我找到一种方法确实能不递归地生成图像（不过思路的确忘了，我先是没有管不要递归的事情，给图形分块，然后慢慢意识到这个方法的），首先我们不妨假设我们后面所有谈论到的一笔画图形都是指所有点都是偶数根线的情况，对于奇数根的，我们先找一条线将两个奇数点连起来，这根线不参与我们的算法，而剩下的就全是偶数点了。然后我们可以证明一件事：**由$n$个点组成的最简一笔画图形就是由$n$个点组成的环** （最简图形是说其不能拆解为更小的图形的组合了，后面我简称其为基本图形），这一点还算明显，我也懒得再写明确的证明了。<br><br>
接下来我们就开始操作我们需要画的图了，我们慢慢用3个、4个、...$n$个点去拆分我们最初的图，直至完全将我们的图拆分到最简（这里当然需要证明拆分一定是可行的，不过我觉得也很显然），然后我们选择一个出发点，挨个地连接这些子图，不过连接过程中每一个能分出去到别的子图的“路口”都分出去连接别的子图。依照这样的策略，我们最终一定能画出全部图形，因为很明显的，每一步之后剩下的图形都是联通的，任意取的两个点一定在两个基本图形之中，而基本图形之间的关系，根据我们的画法，一定是有画的先后顺序的区别的，而且任意两个基本图形，它们很明显是相连的（至少每一个基本图形最后一条线没有画），当然剩下的图形就是连通图了，所以肯定能画出来。